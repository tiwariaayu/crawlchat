datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

type UserSettings {
  openaiApiKey String?
  weeklyUpdates Boolean?
  ticketEmailUpdates Boolean?
}

model User {
  id                  String   @id @default(auto()) @map("_id") @db.ObjectId
  email               String   @unique
  name                String?
  photo               String?
  settings            UserSettings?
  billingEmail        String?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  plan                UserPlan?
  topups              TopupPlan[]

  scrapes             Scrape[]
  scrapeItems         ScrapeItem[]
  ownedMessages       Message[]
  knowoledgeGroups    KnowledgeGroup[]
  scrapeUsers         ScrapeUser[]
  ApiActions          ApiAction[]
}

enum ScrapeStatus {
  pending
  scraping
  done
  error
}

type MetaTag {
  key String
  value String
}

enum WidgetSize {
  small
  large
  full_screen
}

type WidgetQuestion {
  text String
}

type WidgetConfig {
  size                  WidgetSize
  questions             WidgetQuestion[]
  welcomeMessage        String?
  showMcpSetup          Boolean?
  textInputPlaceholder  String?
  primaryColor          String?
  buttonText            String?
  buttonTextColor       String?
  showLogo              Boolean?
  tooltip               String?
  private               Boolean?
  logoUrl               String?
  applyColorsToChatbox  Boolean?
}

type ScrapeAnalyticsCategoryMessageId {
  id                  String @db.ObjectId
}

type ScrapeAnalyticsCategory {
  key                 String
  name                String
  description         String
  messageIds          ScrapeAnalyticsCategoryMessageId[]
}

type ScrapeAnalytics {
  categories          ScrapeAnalyticsCategory[]
  updatedAt           DateTime
}

type DiscordDraftConfig {
  emoji                   String
  sourceChannelIds        String[]
  destinationChannelId    String
}

type DiscordConfig {
  replyAsThread Boolean?
  onlyChannelNames String?
  sendImages Boolean?
}

enum LlmModel {
  gpt_4o_mini
  o3_mini
  sonnet_3_7
  sonnet_3_5
  gemini_2_5_flash
  gemini_2_5_flash_lite
  o4_mini

  gpt_5_nano
  gpt_5_mini
  gpt_5
}

type RichBlockConfig {
  name                String
  key                 String
  payload             Json
  prompt              String
}

type RichBlocksConfig {
  blocks              RichBlockConfig[]
}

type ResolveBtnConfig {
  btnLabel            String
  title               String
  description         String
  link                String
}

type SlackConfig {
  installation          Json
  replyBroadcast        Boolean?
}

model Scrape {
  id                    String   @id @default(auto()) @map("_id") @db.ObjectId
  userId                String   @db.ObjectId

  url                   String?
  status                ScrapeStatus
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  title                 String?
  chatPrompt            String?
  mcpToolName           String?
  widgetConfig          WidgetConfig?
  indexer               String?
  discordServerId       String?
  discordDraftConfig    DiscordDraftConfig?
  discordConfig         DiscordConfig?
  logoUrl               String?
  ticketingEnabled      Boolean?
  
  resolveQuestion       String?
  resolveDescription    String?
  resolveYesConfig      ResolveBtnConfig?
  resolveNoConfig       ResolveBtnConfig?

  slackTeamId           String?
  slackConfig           SlackConfig?

  analytics             ScrapeAnalytics?
  llmModel              LlmModel?
  richBlocksConfig      RichBlocksConfig?
  minScore              Float?
  slug                  String?
  showSources           Boolean?
  analyseMessage        Boolean?
  lowCreditsMailSentAt  DateTime?

  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  threads               Thread[]
  items                 ScrapeItem[]
  messages              Message[]
  knowoledgeGroups      KnowledgeGroup[]
  scrapeUsers           ScrapeUser[]
  apiActions            ApiAction[]

  @@index([slug])
}

type MessageSourceLink {
  url                     String?
  title                   String?
  score                   Float?
  scrapeItemId            String?     @db.ObjectId
  knowledgeGroupId        String?     @db.ObjectId
  fetchUniqueId           String?
  searchQuery             String?
}

enum MessageChannel {
  mcp
  discord
  slack
  widget
}

enum MessageRating {
  up
  down
  none
}

enum TicketAuthorRole {
  user
  agent
}

enum TicketEvent {
  message
}

type TicketMessage {
  role                      TicketAuthorRole
  event                     TicketEvent
}

enum QuestionSentiment {
  sad
  neutral
  happy
}

type MessageAnalysis {
  category  String?
  questionRelevanceScore Float?
  questionSentiment QuestionSentiment?
  
  dataGapTitle String?
  dataGapDescription String?
  dataGapDone Boolean?
}

model Message {
  id                        String   @id @default(auto()) @map("_id") @db.ObjectId
  threadId                  String   @db.ObjectId
  ownerUserId               String   @db.ObjectId
  scrapeId                  String   @db.ObjectId
  questionId                String?  @db.ObjectId

  llmMessage                Json
  links                     MessageSourceLink[]
  pinnedAt                  DateTime?
  channel                   MessageChannel?
  rating                    MessageRating?
  correctionItemId          String?  @db.ObjectId
  ticketMessage             TicketMessage?
  apiActionCalls            ApiActionCall[]

  slackMessageId            String?
  discordMessageId          String?
  analysis                  MessageAnalysis?

  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  thread                    Thread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  ownerUser                 User @relation(fields: [ownerUserId], references: [id], onDelete: Cascade)
  scrape                    Scrape @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
  correctionItem            ScrapeItem? @relation(fields: [correctionItemId], references: [id])

  @@index([ownerUserId, scrapeId, createdAt])
}

enum ResponseType {
  short
  brief
  long
  points
}

enum TicketStatus {
  open
  closed
}

type Location {
  country         String?
  region          String?
  city            String?
}

model Thread {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  scrapeId        String   @db.ObjectId

  responseType    ResponseType?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  openedAt        DateTime?
  isDefault       Boolean?
  lastMessageAt   DateTime?
  title           String?

  ticketNumber    Int?
  ticketKey       String?
  ticketStatus    TicketStatus?
  ticketClosedAt  DateTime?
  ticketUserEmail String?
  customTags      Json?
  location        Location?

  scrape          Scrape   @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
  
  messages        Message[]
}

type Embedding {
  id String
}

enum ScrapeItemStatus {
  completed
  failed
}

model ScrapeItem {
  id                      String   @id @default(auto()) @map("_id") @db.ObjectId
  scrapeId                String   @db.ObjectId
  userId                  String   @db.ObjectId
  knowledgeGroupId        String   @db.ObjectId

  url                     String?
  title                   String?
  markdown                String?
  metaTags                MetaTag[]
  embeddings              Embedding[]
  status                  ScrapeItemStatus?
  error                   String?

  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  scrape                  Scrape   @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
  user                    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  knowledgeGroup          KnowledgeGroup?  @relation(fields: [knowledgeGroupId], references: [id], onDelete: Cascade)
  correctetdMessages      Message[]

  @@unique([knowledgeGroupId, url])
}

enum UserPlanProvider {
  STRIPE
  LEMONSQUEEZY
  CUSTOM
}

enum PlanType {
  FREE
  SUBSCRIPTION
  ONE_TIME
}

enum PlanStatus {
  ACTIVE
  EXPIRED
}

type PlanCredits {
  messages    Float
  scrapes     Float
}

type PlanLimits {
  scrapes     Float
  teamMembers Float
}

type UserPlan {
  planId            String
  type              PlanType
  provider          UserPlanProvider
  subscriptionId    String?
  orderId           String?
  status            PlanStatus

  credits           PlanCredits?
  limits            PlanLimits?

  expiresAt         DateTime?
  activatedAt       DateTime
}

type TopupPlan {
  planId String
  credits PlanCredits
  orderId String?

  createdAt DateTime
  provider UserPlanProvider?
}

enum KnowledgeGroupType {
  scrape_web
  scrape_github
  learn_discord
  learn_slack
  github_issues
  answer_corrections
  upload
  notion
}

enum KnowledgeGroupStatus {
  pending
  processing
  done
  error
}

enum KnowledgeGroupUpdateFrequency {
  minutely
  hourly
  never
  daily
  weekly
  monthly
}

model KnowledgeGroup {
  id                                        String   @id @default(auto()) @map("_id") @db.ObjectId
  scrapeId                                  String   @db.ObjectId
  userId                                    String   @db.ObjectId

  type                                      KnowledgeGroupType
  subType                                   String?
  status                                    KnowledgeGroupStatus
  
  title                                     String?

  url                                       String?
  matchPrefix                               Boolean?
  removeHtmlTags                            String?
  maxPages                                  Int?
  staticContentThresholdLength              Int?
  skipPageRegex                             String?
  scrollSelector                            String?

  githubUrl                                 String?
  githubBranch                              String?
  updateFrequency                           KnowledgeGroupUpdateFrequency?
  nextUpdateAt                              DateTime?
  lastUpdatedAt                             DateTime?
  itemContext                               String?
  notionSecret                              String?

  createdAt                                 DateTime @default(now())
  updatedAt                                 DateTime @updatedAt

  scrape                                    Scrape   @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
  user                                      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  scrapeItems                               ScrapeItem[]
}

model Counter {
  id                                        String @id @map("_id")
  count                                     Int
}

enum UserRole {
  owner
  admin
  member
}

model ScrapeUser {
  id              String  @id @default(auto()) @map("_id") @db.ObjectId
  scrapeId        String  @db.ObjectId
  email           String
  role            UserRole
  userId          String?  @db.ObjectId
  invited         Boolean?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user            User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  scrape          Scrape @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
}

enum ApiActionDataType {
  string
  number
  boolean
}

enum ApiActionItemType {
  dynamic
  value
}

type ApiActionDataItem {
  type ApiActionItemType
  key String
  dataType ApiActionDataType
  description String
  value String?
}

type ApiActionData {
  items ApiActionDataItem[]
}

enum ApiActionMethod {
  get
  post
  delete
  put
}

enum ApiActionType {
  custom
  cal
}

type CalActionConfig {
  apiKey  String?
  eventTypeId String?
}

model ApiAction {
  id              String  @id @default(auto()) @map("_id") @db.ObjectId
  userId          String  @db.ObjectId
  scrapeId        String  @db.ObjectId
  
  title           String
  url             String
  method          ApiActionMethod
  data            ApiActionData
  headers         ApiActionData
  description     String
  type            ApiActionType?
  calConfig       CalActionConfig?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user            User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  scrape          Scrape   @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
}

type ApiActionCall {
  actionId        String  @db.ObjectId
  data            Json
  response        String
  statusCode      Int
  createdAt       DateTime
}