datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

type UserSettings {
  openaiApiKey String?
  weeklyUpdates Boolean?
  ticketEmailUpdates Boolean?
  dataGapEmailUpdates Boolean?
}

model User {
  id                  String   @id @default(auto()) @map("_id") @db.ObjectId
  email               String   @unique
  name                String?
  photo               String?
  settings            UserSettings?
  billingEmail        String?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  showOnboarding      Boolean?

  plan                UserPlan?
  topups              TopupPlan[]

  scrapes             Scrape[]
  scrapeItems         ScrapeItem[]
  ownedMessages       Message[]
  knowoledgeGroups    KnowledgeGroup[]
  scrapeUsers         ScrapeUser[]
  apiActions          ApiAction[]
  apiKeys             ApiKey[]
  articles            Article[]
}

enum ScrapeStatus {
  pending
  scraping
  done
  error
}

type MetaTag {
  key String
  value String
}

enum WidgetSize {
  small
  large
  full_screen
}

type WidgetQuestion {
  text String
}

type WidgetConfig {
  size                  WidgetSize
  questions             WidgetQuestion[]
  welcomeMessage        String?
  showMcpSetup          Boolean?
  textInputPlaceholder  String?
  primaryColor          String?
  buttonText            String?
  buttonTextColor       String?
  showLogo              Boolean?
  tooltip               String?
  logoUrl               String?
  applyColorsToChatbox  Boolean?
  title                 String?
  hideBranding          Boolean?
  currentPageContext    Boolean?
}

type ScrapeAnalyticsCategoryMessageId {
  id                  String @db.ObjectId
}

type ScrapeAnalyticsCategory {
  key                 String
  name                String
  description         String
  messageIds          ScrapeAnalyticsCategoryMessageId[]
}

type ScrapeAnalytics {
  categories          ScrapeAnalyticsCategory[]
  updatedAt           DateTime
}

type DiscordDraftConfig {
  emoji                   String
  sourceChannelIds        String[]
  destinationChannelId    String
}

type DiscordConfig {
  replyAsThread Boolean?
  onlyChannelNames String?
  sendImages Boolean?
}

enum LlmModel {
  gpt_4o_mini
  o3_mini
  sonnet_3_7
  sonnet_3_5
  gemini_2_5_flash
  gemini_2_5_flash_lite
  o4_mini

  gpt_5_nano
  gpt_5_mini
  gpt_5

  sonnet_4_5
  haiku_4_5
}

type RichBlockConfig {
  name                String
  key                 String
  payload             Json
  prompt              String
}

type RichBlocksConfig {
  blocks              RichBlockConfig[]
}

type ResolveBtnConfig {
  btnLabel            String
  title               String
  description         String
  link                String
}

type SlackConfig {
  installation          Json
  replyBroadcast        Boolean?
}

type HelpdeskNavLink {
  label String
  href String
}

type HelpdeskConfig {
  enabled Boolean?
  heroBg String?
  logo String?
  heroTitle String?
  navLinks HelpdeskNavLink[]
  searchPlaceholder String?
}

type ScrapeMessageCategory {
  title String
  createdAt DateTime
  description String
}

model Scrape {
  id                    String   @id @default(auto()) @map("_id") @db.ObjectId
  userId                String   @db.ObjectId

  url                   String?
  status                ScrapeStatus
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  title                 String?
  chatPrompt            String?
  mcpToolName           String?
  widgetConfig          WidgetConfig?
  indexer               String?
  discordServerId       String?
  discordDraftConfig    DiscordDraftConfig?
  discordConfig         DiscordConfig?
  logoUrl               String?
  ticketingEnabled      Boolean?
  
  resolveQuestion       String?
  resolveDescription    String?
  resolveYesConfig      ResolveBtnConfig?
  resolveNoConfig       ResolveBtnConfig?

  slackTeamId           String?
  slackConfig           SlackConfig?

  helpdeskConfig        HelpdeskConfig?

  private               Boolean?

  analytics             ScrapeAnalytics?
  llmModel              LlmModel?
  richBlocksConfig      RichBlocksConfig?
  minScore              Float?
  slug                  String?
  showSources           Boolean?
  analyseMessage        Boolean?
  lowCreditsMailSentAt  DateTime?

  messageCategories     ScrapeMessageCategory[]

  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  threads               Thread[]
  items                 ScrapeItem[]
  messages              Message[]
  knowoledgeGroups      KnowledgeGroup[]
  scrapeUsers           ScrapeUser[]
  apiActions            ApiAction[]
  articles              Article[]

  @@index([slug])
}

type MessageSourceLink {
  url                     String?
  title                   String?
  score                   Float?
  scrapeItemId            String?     @db.ObjectId
  knowledgeGroupId        String?     @db.ObjectId
  fetchUniqueId           String?
  searchQuery             String?
}

enum MessageChannel {
  mcp
  discord
  slack
  widget
  api
  google_chat
}

enum MessageRating {
  up
  down
  none
}

enum TicketAuthorRole {
  user
  agent
}

enum TicketEvent {
  message
}

type TicketMessage {
  role                      TicketAuthorRole
  event                     TicketEvent
}

enum QuestionSentiment {
  sad
  neutral
  happy
}

type CategorySuggestion {
  title String
  description String
}

type MessageAnalysis {
  category  String?
  questionRelevanceScore Float?
  questionSentiment QuestionSentiment?
  
  dataGapTitle String?
  dataGapDescription String?
  dataGapDone Boolean?
  
  shortQuestion String?
  followUpQuestions String[]

  categorySuggestions CategorySuggestion[]
  resolved Boolean?
}

type LlmMessage {
  role String?
  content Json?
}

enum MessageAttachmentType {
  text
}

type MessageAttachment {
  name        String
  type        MessageAttachmentType
  content     String?
}

model Message {
  id                        String   @id @default(auto()) @map("_id") @db.ObjectId
  threadId                  String   @db.ObjectId
  ownerUserId               String   @db.ObjectId
  scrapeId                  String   @db.ObjectId
  questionId                String?  @db.ObjectId

  llmMessage                LlmMessage?
  links                     MessageSourceLink[]
  pinnedAt                  DateTime?
  channel                   MessageChannel?
  rating                    MessageRating?
  correctionItemId          String?  @db.ObjectId
  ticketMessage             TicketMessage?
  apiActionCalls            ApiActionCall[]
  attachments               MessageAttachment[]

  slackMessageId            String?
  discordMessageId          String?
  analysis                  MessageAnalysis?
  llmModel                  LlmModel?
  creditsUsed               Int?
  fingerprint               String?
  url                       String?

  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  thread                    Thread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  ownerUser                 User @relation(fields: [ownerUserId], references: [id], onDelete: Cascade)
  scrape                    Scrape @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
  correctionItem            ScrapeItem? @relation(fields: [correctionItemId], references: [id])

  @@index([ownerUserId, scrapeId, createdAt])
}

enum ResponseType {
  short
  brief
  long
  points
}

enum TicketStatus {
  open
  closed
}

type Location {
  country         String?
  region          String?
  city            String?
}

model Thread {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  scrapeId        String   @db.ObjectId

  responseType    ResponseType?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  openedAt        DateTime?
  isDefault       Boolean?
  lastMessageAt   DateTime?
  title           String?

  ticketNumber    Int?
  ticketKey       String?
  ticketStatus    TicketStatus?
  ticketClosedAt  DateTime?
  ticketUserEmail String?
  customTags      Json?
  location        Location?
  emailVerifiedAt DateTime?
  emailOtp        String?
  emailEntered    String?

  clientThreadId  String?
  fingerprint     String?

  scrape          Scrape   @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
  
  messages        Message[]
}

type Embedding {
  id String
}

enum ScrapeItemStatus {
  pending
  completed
  failed
}

model ScrapeItem {
  id                      String   @id @default(auto()) @map("_id") @db.ObjectId
  scrapeId                String   @db.ObjectId
  userId                  String   @db.ObjectId
  knowledgeGroupId        String   @db.ObjectId

  url                     String?
  title                   String?
  markdown                String?
  metaTags                MetaTag[]
  embeddings              Embedding[]
  status                  ScrapeItemStatus?
  error                   String?
  sourcePageId            String?

  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  scrape                  Scrape   @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
  user                    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  knowledgeGroup          KnowledgeGroup?  @relation(fields: [knowledgeGroupId], references: [id], onDelete: Cascade)
  correctetdMessages      Message[]

  @@unique([knowledgeGroupId, url])
  @@unique([knowledgeGroupId, sourcePageId])
}

enum UserPlanProvider {
  STRIPE
  LEMONSQUEEZY
  DODO
  CUSTOM
}

enum PlanType {
  FREE
  SUBSCRIPTION
  ONE_TIME
}

enum PlanStatus {
  ACTIVE
  EXPIRED
}

type PlanCredits {
  messages    Float
  scrapes     Float
}

type PlanLimits {
  scrapes     Float
  teamMembers Float
  pages       Float
}

type BrandRemovalPlan {
  subscriptionId    String?
}

type UserPlan {
  planId            String
  type              PlanType
  provider          UserPlanProvider
  subscriptionId    String?
  orderId           String?
  status            PlanStatus

  credits           PlanCredits?
  limits            PlanLimits?

  brandRemoval      BrandRemovalPlan?

  expiresAt         DateTime?
  activatedAt       DateTime
  creditsResetAt    DateTime?
}

type TopupPlan {
  planId String
  credits PlanCredits
  orderId String?

  createdAt DateTime
  provider UserPlanProvider?
}

enum KnowledgeGroupType {
  scrape_web
  scrape_github
  learn_discord
  learn_slack
  github_issues
  answer_corrections
  upload
  notion
  confluence
  linear
  custom
  youtube
  youtube_channel
}

enum KnowledgeGroupStatus {
  pending
  processing
  done
  error
}

enum KnowledgeGroupUpdateFrequency {
  minutely
  hourly
  never
  daily
  weekly
  monthly
}

type KnowledgeGroupUrlItem {
  url String
}

model KnowledgeGroup {
  id                                        String   @id @default(auto()) @map("_id") @db.ObjectId
  scrapeId                                  String   @db.ObjectId
  userId                                    String   @db.ObjectId

  type                                      KnowledgeGroupType
  subType                                   String?
  status                                    KnowledgeGroupStatus
  
  title                                     String?

  url                                       String?
  matchPrefix                               Boolean?
  removeHtmlTags                            String?
  maxPages                                  Int?
  staticContentThresholdLength              Int?
  skipPageRegex                             String?
  scrollSelector                            String?
  maxWait                                   Int?

  githubUrl                                 String?
  githubBranch                              String?
  updateFrequency                           KnowledgeGroupUpdateFrequency?
  nextUpdateAt                              DateTime?
  lastUpdatedAt                             DateTime?
  itemContext                               String?
  notionSecret                              String?

  confluenceApiKey                          String?
  confluenceEmail                           String?
  confluenceHost                            String?

  linearApiKey                              String?
  linearSkipIssueStatuses                   String?
  linearSkipProjectStatuses                 String?
  updateProcessId                           String?

  allowedGithubIssueStates                  String?

  fetchError                                String?
  urls                                      KnowledgeGroupUrlItem[]

  createdAt                                 DateTime @default(now())
  updatedAt                                 DateTime @updatedAt

  scrape                                    Scrape   @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
  user                                      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  scrapeItems                               ScrapeItem[]
}

model Counter {
  id                                        String @id @map("_id")
  count                                     Int
}

enum UserRole {
  owner
  admin
  member
}

model ScrapeUser {
  id              String  @id @default(auto()) @map("_id") @db.ObjectId
  scrapeId        String  @db.ObjectId
  email           String
  role            UserRole
  userId          String?  @db.ObjectId
  invited         Boolean?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user            User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  scrape          Scrape @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
}

enum ApiActionDataType {
  string
  number
  boolean
}

enum ApiActionItemType {
  dynamic
  value
}

type ApiActionDataItem {
  type ApiActionItemType
  key String
  dataType ApiActionDataType
  description String
  value String?
}

type ApiActionData {
  items ApiActionDataItem[]
}

enum ApiActionMethod {
  get
  post
  delete
  put
}

enum ApiActionType {
  custom
  cal
  linear_create_issue
}

type CalActionConfig {
  apiKey  String?
  eventTypeId String?
}

type LinearConfig {
  apiKey  String?
  teamId  String?
}

model ApiAction {
  id              String  @id @default(auto()) @map("_id") @db.ObjectId
  userId          String  @db.ObjectId
  scrapeId        String  @db.ObjectId
  
  title           String
  url             String
  method          ApiActionMethod
  data            ApiActionData
  headers         ApiActionData
  description     String
  type            ApiActionType?
  calConfig       CalActionConfig?
  linearConfig    LinearConfig?

  requireEmailVerification Boolean?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user            User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  scrape          Scrape   @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
}

type ApiActionCall {
  actionId        String  @db.ObjectId
  data            Json
  response        String
  statusCode      Int
  createdAt       DateTime
}

model ApiKey {
  id              String  @id @default(auto()) @map("_id") @db.ObjectId
  userId          String  @db.ObjectId
  key             String
  title           String

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum ArticlePurpose {
  guide
}

model Article {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  userId          String   @db.ObjectId
  scrapeId        String   @db.ObjectId

  purpose         ArticlePurpose   @default(guide)
  title           String?
  content         String

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  scrape          Scrape   @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
}