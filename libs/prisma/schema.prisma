datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

type UserSettings {
  openaiApiKey String?
  weeklyUpdates Boolean?
}

model User {
  id                  String   @id @default(auto()) @map("_id") @db.ObjectId
  email               String   @unique
  settings            UserSettings?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  plan                UserPlan?
  topups              TopupPlan[]

  scrapes             Scrape[]
  scrapeItems         ScrapeItem[]
  ownedMessages       Message[]
  knowoledgeGroups    KnowledgeGroup[]
}

enum ScrapeStatus {
  pending
  scraping
  done
  error
}

type MetaTag {
  key String
  value String
}

enum WidgetSize {
  small
  large
  full_screen
}

type WidgetQuestion {
  text String
}

type WidgetConfig {
  size                  WidgetSize
  questions             WidgetQuestion[]
  welcomeMessage        String?
  showMcpSetup          Boolean?
  textInputPlaceholder  String?
}

type ScrapeAnalyticsCategoryMessageId {
  id                  String @db.ObjectId
}

type ScrapeAnalyticsCategory {
  key                 String
  name                String
  description         String
  messageIds          ScrapeAnalyticsCategoryMessageId[]
}

type ScrapeAnalytics {
  categories          ScrapeAnalyticsCategory[]
  updatedAt           DateTime
}

type DiscordDraftConfig {
  emoji                   String
  sourceChannelIds        String[]
  destinationChannelId    String
}

enum LlmModel {
  gpt_4o_mini
  o3_mini
  sonnet_3_7
  sonnet_3_5
  gemini_2_5_flash
}

type RichBlockConfig {
  name                String
  key                 String
  payload             Json
  prompt              String
}

type RichBlocksConfig {
  blocks              RichBlockConfig[]
}

type ResolveBtnConfig {
  btnLabel            String
  title               String
  description         String
  link                String
}

model Scrape {
  id                    String   @id @default(auto()) @map("_id") @db.ObjectId
  userId                String   @db.ObjectId

  url                   String?
  status                ScrapeStatus
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  title                 String?
  chatPrompt            String?
  mcpToolName           String?
  widgetConfig          WidgetConfig?
  indexer               String?
  discordServerId       String?
  discordDraftConfig    DiscordDraftConfig?
  logoUrl               String?
  ticketingEnabled      Boolean?
  
  resolveQuestion       String?
  resolveDescription    String?
  resolveYesConfig      ResolveBtnConfig?
  resolveNoConfig       ResolveBtnConfig?

  analytics             ScrapeAnalytics?
  llmModel              LlmModel?
  richBlocksConfig      RichBlocksConfig?
  minScore              Float?

  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  threads               Thread[]
  items                 ScrapeItem[]
  messages              Message[]
  knowoledgeGroups      KnowledgeGroup[]
}

type MessageSourceLink {
  url                     String?
  title                   String?
  score                   Float?
  scrapeItemId            String?     @db.ObjectId
  knowledgeGroupId        String?     @db.ObjectId
  fetchUniqueId           String?
}

enum MessageChannel {
  mcp
  discord
}

enum MessageRating {
  up
  down
  none
}

enum TicketAuthorRole {
  user
  agent
}

enum TicketEvent {
  message
}

type TicketMessage {
  role                      TicketAuthorRole
  event                     TicketEvent
}

model Message {
  id                        String   @id @default(auto()) @map("_id") @db.ObjectId
  threadId                  String   @db.ObjectId
  ownerUserId               String   @db.ObjectId
  scrapeId                  String   @db.ObjectId

  llmMessage                Json
  links                     MessageSourceLink[]
  pinnedAt                  DateTime?
  channel                   MessageChannel?
  rating                    MessageRating?
  correctionItemId          String?  @db.ObjectId
  ticketMessage             TicketMessage?

  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  thread                    Thread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  ownerUser                 User @relation(fields: [ownerUserId], references: [id], onDelete: Cascade)
  scrape                    Scrape @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
  correctionItem            ScrapeItem? @relation(fields: [correctionItemId], references: [id])

  @@index([ownerUserId, scrapeId, createdAt])
}

enum ResponseType {
  short
  brief
  long
  points
}

enum TicketStatus {
  open
  closed
}

model Thread {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  scrapeId        String   @db.ObjectId

  responseType    ResponseType?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  openedAt        DateTime?
  isDefault       Boolean?
  lastMessageAt   DateTime?
  title           String?

  ticketNumber    Int?
  ticketKey       String?
  ticketStatus    TicketStatus?
  ticketClosedAt  DateTime?
  ticketUserEmail String?

  scrape          Scrape   @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
  
  messages        Message[]
}

type Embedding {
  id String
}

enum ScrapeItemStatus {
  completed
  failed
}

model ScrapeItem {
  id                      String   @id @default(auto()) @map("_id") @db.ObjectId
  scrapeId                String   @db.ObjectId
  userId                  String   @db.ObjectId
  knowledgeGroupId        String   @db.ObjectId

  url                     String?
  title                   String?
  markdown                String?
  metaTags                MetaTag[]
  embeddings              Embedding[]
  status                  ScrapeItemStatus?
  error                   String?

  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  scrape                  Scrape   @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
  user                    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  knowledgeGroup          KnowledgeGroup?  @relation(fields: [knowledgeGroupId], references: [id], onDelete: Cascade)
  correctetdMessages      Message[]

  @@unique([knowledgeGroupId, url])
}

enum UserPlanProvider {
  STRIPE
  LEMONSQUEEZY
  CUSTOM
}

enum PlanType {
  FREE
  SUBSCRIPTION
  ONE_TIME
}

enum PlanStatus {
  ACTIVE
  EXPIRED
}

type PlanCredits {
  messages    Float
  scrapes     Float
}

type UserPlan {
  planId            String
  type              PlanType
  provider          UserPlanProvider
  subscriptionId    String?
  orderId           String?
  status            PlanStatus

  credits           PlanCredits?

  expiresAt         DateTime?
  activatedAt       DateTime
}

type TopupPlan {
  planId String
  credits PlanCredits
  orderId String?

  createdAt DateTime
  provider UserPlanProvider?
}

enum KnowledgeGroupType {
  scrape_web
  scrape_github
  learn_discord
  github_issues
  answer_corrections
  upload
}

enum KnowledgeGroupStatus {
  pending
  processing
  done
  error
}

enum KnowledgeGroupUpdateFrequency {
  minutely
  hourly
  never
  daily
  weekly
  monthly
}

model KnowledgeGroup {
  id                                        String   @id @default(auto()) @map("_id") @db.ObjectId
  scrapeId                                  String   @db.ObjectId
  userId                                    String   @db.ObjectId

  type                                      KnowledgeGroupType
  subType                                   String?
  status                                    KnowledgeGroupStatus
  
  title                                     String?

  url                                       String?
  matchPrefix                               Boolean?
  removeHtmlTags                            String?
  maxPages                                  Int?
  staticContentThresholdLength              Int?
  skipPageRegex                             String?
  scrollSelector                            String?

  githubUrl                                 String?
  githubBranch                              String?
  updateFrequency                           KnowledgeGroupUpdateFrequency?
  nextUpdateAt                              DateTime?
  lastUpdatedAt                             DateTime?
  itemContext                               String?

  createdAt                                 DateTime @default(now())
  updatedAt                                 DateTime @updatedAt

  scrape                                    Scrape   @relation(fields: [scrapeId], references: [id], onDelete: Cascade)
  user                                      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  scrapeItems                               ScrapeItem[]
}

model Counter {
  id                                        String @id @map("_id")
  count                                     Int
}